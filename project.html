<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÂÆ∂Èò≤‰∏≠ÂøÉÂ∞æÁâô - ÁõõÂÖ∏Â§ßËû¢Âπï</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Russo+One&family=Noto+Sans+TC:wght@400;900&display=swap" rel="stylesheet">
    
    <!-- React Libs -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tools -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>

    <style>
        body { 
            margin: 0;
            overflow: hidden; 
            font-family: "Noto Sans TC", sans-serif; 
            transition: background 1s ease;
        }
        
        /* Themes */
        .theme-cyber { background: radial-gradient(circle, #1a1a2e, #16213e, #0f3460); color: #00ffea; }
        .theme-retro { background: radial-gradient(circle, #4a0404, #7f1d1d, #2c0b0e); color: #fcd34d; }
        .theme-space { background: linear-gradient(to bottom, #0f0c29, #302b63, #24243e); color: #e0e7ff; }
        .theme-magic { background: radial-gradient(circle at center, #4c1d95, #2e1065, #000000); color: #d8b4fe; }
        .theme-festival { background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 99%, #fecfef 100%); color: #be185d; }

        /* Effects */
        .neon-text { text-shadow: 0 0 10px rgba(0,255,234,0.7), 0 0 20px rgba(0,255,234,0.5); font-family: 'Russo One', sans-serif; }
        .retro-text { text-shadow: 2px 2px 0px #000, 4px 4px 0px #b91c1c; font-family: 'Russo One', sans-serif; letter-spacing: 2px; }
        
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }

        /* Animations */
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .wheel-container { transition: transform 4s cubic-bezier(0.17, 0.67, 0.12, 0.99); }
        .card-flip { transform-style: preserve-3d; transition: transform 0.8s; }
        .card-flip.flipped { transform: rotateY(180deg); }
        .card-face { backface-visibility: hidden; position: absolute; inset: 0; }
        .card-back { transform: rotateY(180deg); }

        /* Meteor Impact */
        @keyframes meteorDrop {
            0% { transform: translate(100%, -100%) scale(0.5); opacity: 1; }
            70% { transform: translate(0, 0) scale(1.5); opacity: 1; }
            100% { transform: translate(-20%, 20%) scale(0.2); opacity: 0; }
        }
        @keyframes impactShake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-10px, 10px); }
            20%, 40%, 60%, 80% { transform: translate(10px, -10px); }
        }
        .animate-impact { animation: impactShake 0.5s ease-in-out; }

        /* Slot Reel Blur Animation */
        @keyframes reelBlur {
            0% { transform: translateY(0); filter: blur(2px); }
            100% { transform: translateY(-50%); filter: blur(2px); }
        }
        .reel-rolling .reel-track {
            animation: reelBlur 0.2s linear infinite;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        const { createRoot } = ReactDOM;
        
        const MQTT_BROKER = 'wss://broker.emqx.io:8084/mqtt';

        // --- ÂæóÁçéÂÖ¨ÂëäÂΩàÁ™ó (Winner Modal) ---
        const WinnerModal = ({ winner, show }) => {
            if (!show || !winner) return null;
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm animate__animated animate__fadeIn">
                    <div className="bg-gradient-to-b from-red-800 to-red-950 p-1 rounded-[3rem] shadow-[0_0_100px_rgba(234,179,8,0.6)] animate__animated animate__zoomInDown">
                        <div className="bg-[url('https://www.transparenttextures.com/patterns/cubes.png')] bg-red-900 rounded-[2.8rem] border-4 border-yellow-500 p-12 text-center relative overflow-hidden min-w-[500px]">
                            <div className="absolute inset-0 bg-gradient-to-t from-yellow-500/20 to-transparent pointer-events-none"></div>
                            <div className="text-yellow-300 font-bold text-3xl mb-6 tracking-widest uppercase drop-shadow-md">Congratulations</div>
                            <div className="mb-8 relative inline-block">
                                <div className="text-9xl animate__animated animate__bounce infinite">{winner.avatar}</div>
                                <div className="absolute -bottom-2 -right-2 text-4xl">üèÜ</div>
                            </div>
                            <div className="text-7xl font-black text-white drop-shadow-xl mb-4">{winner.name}</div>
                            <div className="inline-block bg-yellow-500 text-red-900 px-8 py-2 rounded-full text-xl font-bold shadow-lg">ÊÅ≠Âñú‰∏≠Áçé</div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- 1. [Ë≥ΩÂçö] Áü©Èô£ÊªæÂãï ---
        const VisualCyberScroll = ({ candidates, targetName, isRolling }) => {
            const [display, setDisplay] = useState("SYSTEM READY");
            useEffect(() => {
                if (isRolling) {
                    const interval = setInterval(() => {
                        const randomName = candidates[Math.floor(Math.random() * candidates.length)]?.name || "LOADING...";
                        setDisplay(randomName.toUpperCase());
                    }, 40);
                    return () => clearInterval(interval);
                } else if (targetName) { setDisplay(targetName); }
            }, [isRolling, targetName]);
            return (
                <div className="flex flex-col items-center justify-center h-full">
                    <div className={`text-9xl font-black neon-text tracking-widest transition-all duration-300 ${isRolling ? 'opacity-80 blur-sm scale-95' : 'opacity-100 scale-110'}`}>{display}</div>
                    {isRolling && <div className="mt-8 text-cyan-300 animate-pulse tracking-[1em]">DECODING...</div>}
                </div>
            );
        };

        // --- 2. [Âæ©Âè§] Âπ∏ÈÅãËΩâÁõ§ ---
        const VisualWheel = ({ candidates, targetName, isRolling }) => {
            const [rotation, setRotation] = useState(0);
            useEffect(() => { if (isRolling) setRotation(r => r + 1800 + Math.random() * 360); }, [isRolling]);
            return (
                <div className="flex flex-col items-center justify-center h-full relative">
                    <div className="absolute top-1/4 z-20 text-6xl text-white drop-shadow-lg">‚ñº</div>
                    <div className={`w-[500px] h-[500px] rounded-full border-8 border-yellow-600 relative overflow-hidden shadow-2xl bg-red-900 wheel-container`} style={{ transform: `rotate(${rotation}deg)` }}>
                        <div className="absolute inset-0 flex items-center justify-center">{[0, 45, 90, 135].map(d => <div key={d} className="w-full h-[1px] bg-yellow-500/50 absolute" style={{transform: `rotate(${d}deg)`}}></div>)}</div>
                        <div className="absolute inset-0 flex items-center justify-center"><div className="w-32 h-32 bg-yellow-600 rounded-full border-4 border-yellow-300 shadow-inner flex items-center justify-center"><span className="text-4xl">‚òÖ</span></div></div>
                    </div>
                </div>
            );
        };

        // --- 3. [È≠îÊ≥ï] ÂëΩÈÅãÂ°îÁæÖ ---
        const VisualCards = ({ candidates, targetName, isRolling }) => {
            const [flipped, setFlipped] = useState(false);
            useEffect(() => {
                if (isRolling) setFlipped(false);
                else if (targetName) setTimeout(() => setFlipped(true), 500);
            }, [isRolling, targetName]);
            return (
                <div className="flex items-center justify-center h-full">
                    <div className={`relative w-80 h-[480px] transition-all duration-1000 transform-style-3d ${flipped ? 'rotate-y-180' : ''} ${isRolling ? 'animate-bounce' : ''}`}>
                        <div className="card-face absolute inset-0 bg-gradient-to-br from-indigo-900 to-purple-900 rounded-3xl border-4 border-yellow-400/50 shadow-2xl flex items-center justify-center backface-hidden"><div className="text-8xl opacity-50">üîÆ</div></div>
                        <div className="card-face card-back absolute inset-0 bg-white rounded-3xl border-4 border-purple-600 shadow-[0_0_50px_rgba(168,85,247,0.6)] flex flex-col items-center justify-center backface-hidden">
                            {targetName && <><div className="text-2xl text-purple-800 font-bold mb-8">THE CHOSEN ONE</div><div className="text-6xl font-black text-transparent bg-clip-text bg-gradient-to-r from-purple-600 to-pink-600">{targetName}</div><div className="mt-8 text-4xl">‚ú®</div></>}
                        </div>
                    </div>
                </div>
            );
        };

        // --- 4. [ÁßëÂπª] Èõ∑ÈÅîÈéñÂÆö ---
        const VisualRadar = ({ candidates, targetName, isRolling }) => {
            const [scanName, setScanName] = useState("");
            useEffect(() => {
                if (isRolling) {
                    const t = setInterval(() => setScanName(candidates[Math.floor(Math.random()*candidates.length)]?.name), 100);
                    return () => clearInterval(t);
                } else if (targetName) { setScanName(targetName); }
            }, [isRolling, targetName]);
            return (
                <div className="flex flex-col items-center justify-center h-full relative">
                    <div className="w-[600px] h-[600px] rounded-full border-2 border-green-500/30 relative flex items-center justify-center bg-black/40 shadow-[0_0_50px_rgba(16,185,129,0.2)] overflow-hidden">
                        <div className={`absolute w-1/2 h-1/2 top-0 right-0 bg-gradient-to-t from-green-500/50 to-transparent origin-bottom-left ${isRolling ? 'animate-spin' : 'hidden'}`} style={{animationDuration: '1s'}}></div>
                        <div className="z-10 text-center">
                            <div className="text-green-400 font-mono text-sm mb-2 tracking-widest">{isRolling ? "SCANNING TARGET..." : "TARGET LOCKED"}</div>
                            <div className={`text-6xl font-black font-mono ${isRolling ? 'text-green-500/50 blur-sm' : 'text-green-400 drop-shadow-[0_0_20px_rgba(74,222,128,0.8)] scale-125 transition-transform'}`}>{scanName || "SEARCHING"}</div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- 5. [Ë≥≠Â†¥] ÈªÉÈáëÊãâÈú∏ (3 Reels) ---
        const VisualSlots = ({ candidates, targetName, winner, isRolling }) => {
            const [stopReels, setStopReels] = useState([false, false, false]);
            const reelStrips = useMemo(() => {
                return [0, 1, 2].map(() => {
                    let list = [...candidates];
                    if (list.length < 10) list = [...list, ...list, ...list];
                    return list.sort(() => 0.5 - Math.random()).slice(0, 20);
                });
            }, [candidates]);

            useEffect(() => {
                if (isRolling) {
                    setStopReels([false, false, false]);
                } else if (targetName && winner) {
                    setTimeout(() => setStopReels(prev => [true, false, false]), 100);
                    setTimeout(() => setStopReels(prev => [true, true, false]), 800);
                    setTimeout(() => setStopReels(prev => [true, true, true]), 1500);
                }
            }, [isRolling, targetName, winner]);

            return (
                <div className="flex flex-col items-center justify-center h-full w-full">
                    <div className="bg-gradient-to-b from-yellow-700 to-yellow-900 p-8 rounded-3xl border-8 border-yellow-500 shadow-2xl relative flex gap-4">
                        <div className="absolute -top-6 left-1/2 -translate-x-1/2 bg-red-600 text-white px-8 py-2 rounded-lg font-bold shadow-lg border-2 border-yellow-400 text-2xl tracking-wider z-20">MEGA JACKPOT</div>
                        {[0, 1, 2].map(i => (
                            <div key={i} className="bg-white h-64 w-48 rounded-xl overflow-hidden border-4 border-gray-800 shadow-inner relative">
                                <div className="absolute inset-0 bg-gradient-to-b from-black/40 via-transparent to-black/40 pointer-events-none z-10"></div>
                                <div className={`h-full flex flex-col items-center justify-center ${!stopReels[i] ? 'reel-rolling' : ''}`}>
                                    {!stopReels[i] ? (
                                        <div className="reel-track text-center opacity-50">
                                            {reelStrips[i].map((p, idx) => (
                                                <div key={idx} className="h-64 flex flex-col items-center justify-center">
                                                    <div className="text-5xl">{p.avatar}</div>
                                                    <div className="text-xl font-bold text-gray-400">{p.name}</div>
                                                </div>
                                            ))}
                                        </div>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center animate__animated animate__bounceIn">
                                            <div className="text-8xl mb-4 drop-shadow-md">{winner?.avatar || 'üíé'}</div>
                                            <div className="text-3xl font-black text-red-600">{winner?.name || targetName}</div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        ))}
                        <div className="absolute right-[-60px] top-1/2 -translate-y-1/2 w-12 h-40 bg-gray-400 rounded-r-lg border-l-0 border-4 border-gray-600">
                            <div className="absolute -top-10 left-1/2 -translate-x-1/2 w-8 h-20 bg-red-600 rounded-full shadow-lg"></div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- 6. [Â§™Á©∫] ÊµÅÊòüÈôçËá® (ÂçáÁ¥öÁâàÔºöÊíûÊìäÂú∞ÁêÉ) ---
        const VisualMeteor = ({ candidates, targetName, isRolling }) => {
            const [stars, setStars] = useState([]);
            const [impactStage, setImpactStage] = useState('idle');

            useEffect(() => {
                if(isRolling) {
                    setImpactStage('idle');
                    const t = setInterval(() => {
                        setStars(prev => [...prev.slice(-20), { 
                            id: Math.random(),
                            name: candidates[Math.floor(Math.random()*candidates.length)]?.name,
                            left: Math.random() * 100,
                            duration: 0.3 + Math.random() * 0.5
                        }]);
                    }, 50);
                    return () => clearInterval(t);
                } else if(targetName) {
                    setStars([]);
                    setImpactStage('falling');
                    setTimeout(() => { setImpactStage('impact'); }, 800);
                }
            }, [isRolling, targetName]);

            return (
                <div className={`flex flex-col items-center justify-center h-full relative overflow-hidden ${impactStage === 'impact' ? 'animate-impact' : ''}`}>
                    <div className="absolute -bottom-[600px] left-1/2 -translate-x-1/2 w-[1200px] h-[1200px] bg-blue-500 rounded-full opacity-30 blur-3xl"></div>
                    <div className="absolute -bottom-[500px] left-1/2 -translate-x-1/2 w-[1000px] h-[1000px] bg-blue-600 rounded-full shadow-2xl border-t-4 border-blue-300"></div>
                    {isRolling && stars.map(s => (
                        <div key={s.id} className="absolute text-white/40 font-bold text-xl animate__animated animate__fadeOutDown" 
                             style={{ left: `${s.left}%`, top: '-50px', animationDuration: `${s.duration}s`, animationTimingFunction: 'linear' }}>
                            {s.name}
                        </div>
                    ))}
                    {impactStage === 'falling' && (
                        <div className="absolute top-0 right-0 w-32 h-32 bg-yellow-100 rounded-full blur-md"
                             style={{ animation: 'meteorDrop 0.8s ease-in forwards', right: '45%' }}>
                             <div className="absolute top-10 left-10 w-96 h-2 bg-gradient-to-l from-transparent to-yellow-500 transform -rotate-45 origin-left blur-sm"></div>
                        </div>
                    )}
                    {impactStage === 'impact' && targetName && (
                        <div className="z-20 text-center relative">
                            <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[800px] h-[800px] bg-white rounded-full animate__animated animate__fadeOut" style={{animationDuration: '0.5s'}}></div>
                            <div className="relative z-30 animate__animated animate__zoomIn">
                                <div className="text-[120px] mb-2 filter drop-shadow-[0_0_20px_rgba(255,200,0,0.8)]">‚òÑÔ∏è</div>
                                <div className="text-8xl font-black text-transparent bg-clip-text bg-gradient-to-b from-white to-yellow-300 drop-shadow-2xl">{targetName}</div>
                                <div className="text-yellow-100 mt-6 text-2xl tracking-[1em] uppercase font-bold">Impact Confirmed</div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- 7. [Á•≠ÂÖ∏] Êâ≠ËõãÊ©ü ---
        const VisualGashapon = ({ candidates, targetName, isRolling }) => {
            return (
                <div className="flex flex-col items-center justify-center h-full">
                    <div className={`relative ${isRolling ? 'animate-shake' : ''}`}>
                        <div className="w-80 h-80 bg-white/20 rounded-full border-8 border-pink-400 relative overflow-hidden flex items-center justify-center shadow-2xl backdrop-blur-md">
                            {isRolling ? <div className="text-9xl animate-spin">üåÄ</div> : targetName ? <div className="text-center animate__animated animate__tada"><div className="text-8xl">üéÅ</div></div> : <div className="text-pink-200 text-6xl">?</div>}
                        </div>
                        <div className="w-64 h-32 bg-pink-500 mx-auto mt-[-20px] rounded-b-3xl border-4 border-pink-700 shadow-xl flex items-center justify-center relative z-10"><div className="w-20 h-20 bg-white rounded-full border-4 border-gray-300"></div></div>
                    </div>
                    {!isRolling && targetName && <div className="mt-8 bg-white text-pink-600 px-8 py-4 rounded-full text-4xl font-black shadow-xl animate__animated animate__fadeInUp">{targetName}</div>}
                </div>
            );
        };

        // --- 8. [È©öÊÇö] ÁîüÂ≠òÊ∑òÊ±∞ ---
        const VisualElimination = ({ candidates, targetName, isRolling }) => {
            const [survivors, setSurvivors] = useState([]);
            useEffect(() => {
                if(isRolling) {
                    let list = candidates.slice(0, 50); 
                    setSurvivors(list);
                    const t = setInterval(() => {
                        setSurvivors(prev => {
                            if(prev.length <= 1) return prev;
                            const idx = Math.floor(Math.random() * prev.length);
                            const newList = [...prev];
                            newList.splice(idx, 1); 
                            return newList;
                        });
                    }, 100);
                    return () => clearInterval(t);
                } else if(targetName) { setSurvivors([{ name: targetName }]); }
            }, [isRolling, targetName, candidates]);
            return (
                <div className="flex flex-col items-center justify-center h-full w-full p-12">
                    {!isRolling && targetName ? <div className="text-center animate__animated animate__heartBeat"><div className="text-red-500 font-black text-[8rem] tracking-widest drop-shadow-[0_5px_5px_rgba(0,0,0,1)]">SURVIVOR</div><div className="text-white text-6xl font-bold bg-red-900 px-8 py-2 inline-block">{targetName}</div></div> : <div className="flex flex-wrap justify-center gap-4 opacity-80">{survivors.map((p, i) => <div key={i} className="bg-black/50 text-red-500 border border-red-900 px-4 py-2 font-mono text-xl font-bold">{p.name}</div>)}</div>}
                </div>
            );
        };

        // --- ‰∏ªÁ®ãÂºè HostApp ---
        const HostApp = () => {
            const [roomId, setRoomId] = useState('');
            const [allPlayers, setAllPlayers] = useState([]);
            const [winners, setWinners] = useState([]); 
            const [currentRound, setCurrentRound] = useState(0); 
            const [isDrawing, setIsDrawing] = useState(false);
            const [drawQueue, setDrawQueue] = useState([]); 
            const [currentDisplayWinner, setCurrentDisplayWinner] = useState(null); 
            const [currentDisplayWinnerObj, setCurrentDisplayWinnerObj] = useState(null);
            const [isVisualRolling, setIsVisualRolling] = useState(false); 
            
            const [targetCount, setTargetCount] = useState(1);
            const [gameMode, setGameMode] = useState('cyber'); 
            
            const [showWinnerModal, setShowWinnerModal] = useState(false);
            const [modalWinner, setModalWinner] = useState(null);

            const GAME_MODES = [
                { id: 'cyber', name: 'Áü©Èô£ÊªæÂãï', theme: 'theme-cyber', comp: VisualCyberScroll },
                { id: 'retro', name: 'Âπ∏ÈÅãËΩâÁõ§', theme: 'theme-retro', comp: VisualWheel },
                { id: 'magic', name: 'ÂëΩÈÅãÂ°îÁæÖ', theme: 'theme-magic', comp: VisualCards },
                { id: 'space', name: 'Èõ∑ÈÅîÈéñÂÆö', theme: 'theme-space', comp: VisualRadar },
                { id: 'vegas', name: 'ÈªÉÈáëÊãâÈú∏', theme: 'theme-retro', comp: VisualSlots },
                { id: 'meteor', name: 'ÊµÅÊòüÈôçËá®', theme: 'theme-space', comp: VisualMeteor },
                { id: 'gasha', name: 'Ê≠°Ê®ÇÊâ≠Ëõã', theme: 'theme-festival', comp: VisualGashapon },
                { id: 'battle', name: 'ÁîüÂ≠òÊ∑òÊ±∞', theme: 'theme-cyber', comp: VisualElimination },
            ];
            
            const [unusedModes, setUnusedModes] = useState([...GAME_MODES.map(m => m.id)]);
            const clientRef = useRef(null);

            const speakWinner = (name) => {
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(`ÊÅ≠Âñú ${name} ‰∏≠Áçé`);
                    utterance.lang = 'zh-TW';
                    utterance.rate = 1.0;
                    window.speechSynthesis.speak(utterance);
                }
            };

            useEffect(() => {
                const urlParams = new URLSearchParams(window.location.search);
                let rid = urlParams.get('room');
                if (!rid) rid = Math.floor(1000 + Math.random() * 9000).toString();
                setRoomId(rid);

                const storedPlayers = sessionStorage.getItem(`lottery_players_${rid}`);
                if (storedPlayers) setAllPlayers(JSON.parse(storedPlayers));

                const client = mqtt.connect(MQTT_BROKER);
                clientRef.current = client;
                client.on('connect', () => client.subscribe(`tw_lottery/${rid}/join`));
                client.on('message', (topic, message) => {
                    if (topic.endsWith('/join')) {
                        try {
                            const newPlayer = JSON.parse(message.toString());
                            setAllPlayers(prev => {
                                if (prev.some(p => p.id === newPlayer.id)) return prev;
                                const list = [...prev, newPlayer];
                                sessionStorage.setItem(`lottery_players_${rid}`, JSON.stringify(list));
                                return list;
                            });
                        } catch (e) {}
                    }
                });
                return () => client.end();
            }, []);

            const availablePlayers = useMemo(() => {
                const winnerIds = new Set(winners.map(w => w.id));
                return allPlayers.filter(p => !winnerIds.has(p.id));
            }, [allPlayers, winners]);

            const startDrawProcess = async () => {
                if (availablePlayers.length < targetCount) { alert("‰∫∫Êï∏‰∏çË∂≥ÔºÅ"); return; }
                
                let nextModes = [...unusedModes];
                if (nextModes.length === 0) { nextModes = GAME_MODES.map(m => m.id); }
                const randomIndex = Math.floor(Math.random() * nextModes.length);
                const selectedModeId = nextModes[randomIndex];
                nextModes.splice(randomIndex, 1);
                setUnusedModes(nextModes);
                setGameMode(selectedModeId);
                
                setIsDrawing(true);
                const nextRound = currentRound + 1;
                setCurrentRound(nextRound);

                const pool = [...availablePlayers];
                const roundWinners = [];
                for(let i=0; i<targetCount; i++) {
                    const idx = Math.floor(Math.random() * pool.length);
                    roundWinners.push(pool[idx]);
                    pool.splice(idx, 1);
                }
                setWinners(prev => [...prev, ...roundWinners]);
                
                if (clientRef.current) {
                    clientRef.current.publish(`tw_lottery/${roomId}/status`, JSON.stringify({ status: 'playing', round: nextRound }));
                }

                await processDrawQueue(roundWinners);
            };

            const processDrawQueue = async (queue) => {
                await new Promise(r => setTimeout(r, 500));

                for (let i = 0; i < queue.length; i++) {
                    const winner = queue[i];
                    
                    setIsVisualRolling(true);
                    setCurrentDisplayWinner(null);
                    setCurrentDisplayWinnerObj(null);
                    setShowWinnerModal(false);
                    
                    await new Promise(r => setTimeout(r, 4000));
                    
                    setIsVisualRolling(false);
                    setCurrentDisplayWinner(winner.name);
                    setCurrentDisplayWinnerObj(winner);
                    
                    await new Promise(r => setTimeout(r, 2000));
                    
                    setModalWinner(winner);
                    setShowWinnerModal(true);
                    confetti({ particleCount: 200, spread: 100, origin: { y: 0.6 } });
                    speakWinner(winner.name);
                    
                    await new Promise(r => setTimeout(r, 3500));
                    
                    setShowWinnerModal(false);
                    
                    if (clientRef.current) {
                        clientRef.current.publish(`tw_lottery/${roomId}/status`, JSON.stringify({ 
                            status: 'result', round: currentRound + 1, winnerName: winner.name, winnerId: winner.id 
                        }));
                    }
                    
                    await new Promise(r => setTimeout(r, 500));
                }

                setIsDrawing(false);
                setModalWinner(null);
            };

            const currentModeConfig = GAME_MODES.find(m => m.id === gameMode) || GAME_MODES[0];
            const VisualComponent = currentModeConfig.comp;

            return (
                <div className={`h-screen flex flex-col relative overflow-hidden font-sans transition-colors duration-1000 ${currentModeConfig.theme}`}>
                    <WinnerModal winner={modalWinner} show={showWinnerModal} />

                    <div className="absolute top-0 left-0 w-full p-6 flex justify-between items-start z-20 pointer-events-none">
                         <div className="glass-panel px-8 py-3 rounded-full shadow-lg flex gap-4 items-center">
                             <span className="font-bold text-2xl mr-2">{currentRound === 0 ? "Ê∫ñÂÇôÈñãÂßã" : `Á¨¨ ${currentRound} ÂõûÂêà`}</span>
                             {isDrawing && <span className="bg-red-600 text-white text-xs px-2 py-1 rounded animate-pulse">LIVE - {currentModeConfig.name}</span>}
                         </div>
                         <div className="glass-panel px-6 py-3 rounded-full text-white/80 font-mono">‰∫∫Êï∏: {allPlayers.length}</div>
                    </div>

                    <div className="flex-1 relative z-10 flex items-center justify-center p-8">
                        {allPlayers.length === 0 ? (
                            <div className="text-center animate__animated animate__fadeIn">
                                <div className="text-4xl opacity-50 mb-4 font-bold">Á≠âÂæÖÁé©ÂÆ∂Âä†ÂÖ•...</div>
                            </div>
                        ) : (
                            <VisualComponent 
                                candidates={availablePlayers.concat(drawQueue)} 
                                targetName={currentDisplayWinner}
                                winner={currentDisplayWinnerObj}
                                isRolling={isVisualRolling}                     
                            />
                        )}
                    </div>

                    <div className="absolute bottom-0 w-full p-10 flex flex-col items-center justify-center z-30 pointer-events-none bg-gradient-to-t from-black/80 to-transparent">
                        {!isDrawing && (
                            <div className="flex items-center gap-4 mb-6 bg-black/40 backdrop-blur-md px-6 py-2 rounded-full border border-white/10 pointer-events-auto">
                                <span className="text-sm font-bold opacity-70">Êú¨Ëº™ÊäΩÂá∫</span>
                                <button onClick={() => setTargetCount(Math.max(1, targetCount-1))} className="w-8 h-8 rounded-full bg-white/10 hover:bg-white/20">-</button>
                                <span className="text-2xl font-black w-8 text-center">{targetCount}</span>
                                <button onClick={() => setTargetCount(Math.min(availablePlayers.length, targetCount+1))} className="w-8 h-8 rounded-full bg-white/10 hover:bg-white/20">+</button>
                                <span className="text-sm opacity-50 ml-2">‰∫∫ (Ââ©È§ò {availablePlayers.length})</span>
                            </div>
                        )}

                        <button 
                            onClick={startDrawProcess} 
                            disabled={isDrawing || availablePlayers.length === 0}
                            className={`pointer-events-auto px-16 py-5 rounded-full font-black text-3xl shadow-2xl transition-all transform flex items-center gap-4 border-4
                                ${isDrawing 
                                    ? 'bg-gray-800 text-gray-500 border-gray-700 cursor-not-allowed scale-95' 
                                    : 'bg-gradient-to-r from-yellow-400 to-orange-500 text-red-900 border-yellow-300 hover:scale-105 hover:shadow-yellow-500/50'}`}
                        >
                            {isDrawing ? <><span className="animate-spin">üé≤</span> ÊäΩÁçéÈÄ≤Ë°å‰∏≠...</> : <>{availablePlayers.length === 0 ? "Ê¥ªÂãïÁµêÊùü" : "üöÄ ÈñãÂßãÊäΩÁçé"}</>}
                        </button>
                    </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<HostApp />);
    </script>
</body>
</html>